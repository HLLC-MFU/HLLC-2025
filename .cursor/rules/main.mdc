---
description: 
globs: 
alwaysApply: true
---
You are an expert Go backend engineer specializing in Fiber, gRPC, and clean architecture, using the latest stable version of Go (1.22 or newer).

# ðŸ”§ General Rules
- Use **Go 1.24.1** with Fiber framework and gRPC for internal communication.
- Follow **clean architecture** with clear separation of concerns between layers: handler, controller, service, repository, etc.
- Use the **ctx** pattern with proper context cancellation and timeouts via `WithTimeout` decorator in `backend/pkg/decorator/contextDecorator.go`.
- Always interact with APIs using context passed down from Fiber handlers.
- APIs must be exposed via REST using **Fiber** and backed by **gRPC** logic internally.
- The shared `.proto` definitions are in `backend/pkg/proto/core`, and codegen will be imported and used accordingly.
- No deprecated functions, use the latest idiomatic Go practices.
- Use **cookies** for session-based authentication (not JWT).
- Input must be validated properly and JSON responses must be formatted.
- Middleware lives in `backend/pkg/middleware` (e.g., auth, logging, recovery).
- Reuse common request/response structs in `backend/pkg/common`.
- Redis, gRPC clients, and other integrations live in `backend/pkg/core`.

---

# ðŸ§± Project Structure

backend/
â”œâ”€â”€ config/             # Config structs and loaders
â”œâ”€â”€ env/                # Environment variable files
â”‚   â”œâ”€â”€ dev/
â”‚   â”œâ”€â”€ prod/
â”‚   â””â”€â”€ test/
â”œâ”€â”€ module/             # Each feature module
â”‚   â”œâ”€â”€ auth/           # Authentication Service
â”‚   â”‚   â”œâ”€â”€ controller/
â”‚   â”‚   â”œâ”€â”€ handler/
â”‚   â”‚   â”œâ”€â”€ proto/
â”‚   â”‚   â”œâ”€â”€ repository/
â”‚   â”‚   â””â”€â”€ service/
â”‚   â””â”€â”€ user/           # User Management
â”‚       â”œâ”€â”€ controller/
â”‚       â”œâ”€â”€ handler/
â”‚       â”œâ”€â”€ proto/
â”‚       â”œâ”€â”€ repository/
â”‚       â””â”€â”€ service/
â”œâ”€â”€ pkg/
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â””â”€â”€ model/       # Redis clients, gRPC clients, shared configs
â”‚   â”œâ”€â”€ middleware/      # Auth, recovery, logging middleware
â”‚   â”œâ”€â”€ common/          # Custom request/response bindings
â”‚   â”œâ”€â”€ proto/
â”‚   â”‚   â””â”€â”€ core/        # Shared gRPC/proto messages
â”‚   â”œâ”€â”€ decorator/
â”‚   â”‚   â””â”€â”€ contextDecorator.go  # Global context timeout handler
â”‚   â””â”€â”€ migration/       # Database migration tools
â”œâ”€â”€ scripts/             # Utility/setup scripts
â”œâ”€â”€ server/
â”‚   â”œâ”€â”€ server.go        # Service router with switch-case
â”‚   â”œâ”€â”€ authServer.go    # auth module service starter
â”‚   â””â”€â”€ userServer.go    # user module service starter
â””â”€â”€ main.go              # Application entrypoint

# ðŸ”Œ gRPC â†” REST Mapping
- All internal logic in `service/` and `controller/` will call gRPC clients under `pkg/core/model`.
- REST Fiber handlers (in `handler/`) will:
  - Validate input using `pkg/common`
  - Bind context with `WithTimeout`
  - Call `controller/` methods with context
  - Controller calls gRPC via service and repository layer
  - All routes return JSON responses
- Use `WithTimeout` for all context passing, ensuring clean cancellation.

```go
// Use WithTimeout for context
result, err := decorator.WithTimeout(3 * time.Second)(func(ctx context.Context) (ResultType, error) {
    return svc.DoSomething(ctx, input)
})(c.Context())
```

# ðŸ§ª gRPC Implementation
Each module must:

- Define `.proto` files in `module/<name>/proto/`
- Generate gRPC server/client code
- Implement gRPC server in `service/`
- Register gRPC service and map REST routes to gRPC client via `controller/`
- Shared proto types must be imported from `pkg/proto/core`

---

# ðŸ§­ REST API Setup with Fiber
- All routes registered in `server/<service>.go`
- Middlewares (logging, error recovery, auth) applied globally per service
- Context passed into every handler must use `.Context()` from Fiber
- Routes must use RESTful conventions

```go
app.Post("/user", middleware.Auth(), userHandler.CreateUser)
app.Get("/user/:id", middleware.Auth(), userHandler.GetUserByID)
```

# Server Entry Logic

The main entry point is in `main.go`, which loads the configuration, sets up the gRPC client, and initializes the Fiber app.

## Service Initialization

In `server/server.go`, the application name is switched to initialize the correct routes:

```go
switch s.config.App.Name {
case "user":
    s.userService()
case "auth":
    s.authService()
case "major":
    s.majorService()
case "school":
    s.schoolService()
default:
    return fmt.Errorf("unknown service name: %s", s.config.App.Name)
}
```

## ðŸ§± New Module Creation Rule

To create a new module, follow these steps:

1. Create a directory: `backend/module/<name>/`
2. Add clean architecture folders:
   - `handler/`
   - `controller/`
   - `repository/`
   - `service/`
   - `proto/`
3. Define the `.proto` file and generate the gRPC server/client.
4. Implement the gRPC server in `service/`.
5. Map the gRPC client in `controller/` and connect REST via `handler/`.
6. Register the new module in `server/<name>.go`.
7. Add a new case in `server/server.go`.

## ðŸ§¼ Best Practices

- Always validate inputs before use.
- Always wrap Fiber context with the `WithTimeout` decorator.
- Use proper error responses and HTTP status codes.
- Ensure gRPC is fully implemented and mapped to the REST API.
- Middleware must be reusable and registered via `pkg/middleware`.
- No business logic should reside in `handler/`; delegate it to `controller/`.
- Use `pkg/common` for standardized request/response models.
- Leverage Go concurrency for performance while ensuring context safety.
